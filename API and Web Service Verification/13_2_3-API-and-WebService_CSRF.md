## ASVS Requirement: V13.2.3 Cross Site Request Forgery protection
## ASVS:13.2.3

## ASVS Requirement description
Verify that RESTful web services that utilize cookies are protected from Cross-Site Request Forgery via the use of at least one or more of the following: triple or double submit cookie pattern, CSRF nonces, or ORIGIN request header checks.

## User Story
**Feature_Name**: Cross-Site Request Forgery protection

**Story**:\
As a Security Engineer\
I want to protect and harden the use of session cookies against CSRF attacks\
So that I can be protected against malicious websites performing unwanted changes on trusted websites

## Scenario
**Scenario_name**: Use of built-in CSRF protections

**Gherkin syntax**:
```gherkin
Given the use of session cookies
When I select a framework
Then I choose a `framework` which has built-in CSRF protection
```
Relevant `framework` could be:
For Java: OWASP CSRF Guard or Spring Security
For PHP and Apache: CSRFProtector Project
For AngularJS: Cross-Site Request Forgery (XSRF) Protection

**Scenario_name**: Secure generation of CSRF token

**Gherkin syntax**:
```gherkin
Given the use of user sessions
When I create a CSRF token
Then ensure they are unique per user session
And they are not using an `insecure method`
And that session ID is a large random value generated by a `secure method`
```
`insecure method` includes the following:
For C: use of `random()` and `rand()`
For Java: use of `java.util.Random()`
For PHP: use of `rand()`, `mt_rand()`, `array_rand()` and `uniqid()`
For .NET/C#: use of `Random()`
For Objective-C: use of `arcrandom()`
For NodeJS: use of `Math.random()`
For Python: use of `random()`
For Ruby: use of `Random`
For Go: use of `rand` using `math/rand` package
For Rust: use of `rand::prng::XorShiftRng`

`secure method` includes the following:
For C: use of `getrandom(2)`
For Java: use of `java.security.SecureRandom`
For PHP: use of `random_bytes()` and `random_int()` in PHP 7 or `openssl_random_pseudo_bytes()` in PHP 5
For .NET/C#: use of `RNGCryptoServiceProvider`
For Objective-C: use of `SecRandomCopyBytes`
For Python: use of `secrets()`
For Ruby: use of `SecureRandom`
For Go: use of `crypto.rand` package
For Rust: use of `rand::prng::chacha::ChaChaRng` and the rest of the Rust library `CSNPRNGs`

**Scenario_name**: Token-based mitigation with Synchronizer Token Pattern

**Gherkin syntax**:
```gherkin
Given a request issued by the client
When receive a request from the client
Then I verify the existence and validity of the token
And compare it to the token found in the user session
```

**Scenario_name**: CSRF token transmission

**Gherkin syntax**:
```gherkin
Given the receipt of an authenticated request by the client
When I transmit a CSRF token
Then transmit through a custom HTTP request header
```

**Scenario_name**: SameSite Cookie Attribute

**Gherkin syntax**:
```gherkin
Given the use of cookies to mitigate CSRF attacks
When define cookie attributes
Then I ensure that `SameSite` attribute is defined
And that the `value` is appropriate to my use-case
```

`value` can be `Lax` (enabling only first-party cookies to be sent or accessed), `Strict` (which won't fire if incoming link is from an external site) or `None` (signaling that cookie data can be shared with 3rd parties)

## Validations

**Chef Inspec**

TBC

**OPA**

TBC

**External Tests**

TBC

**External link**\
https://cheatsheetseries.owasp.org/cheatsheets/REST_Assessment_Cheat_Sheet.html
https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html
https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html
https://cwe.mitre.org/data/definitions/352